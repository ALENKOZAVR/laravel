https://zoom.us/s/89502170762#success









Индикатором того что вам нужны тесты на сущ. проекте
это то что в системе начали появляться неконтроллируемые баги
делаете одно, а ломаете другое
и у программистов подсознательно возникает боязнь, когда ты не знаешь что твое изменения в системе
в одном месте, сломает в другом

Тесты - доказательство того что ваш код работает

+---------------------------+
|                           |
|        -----------        |
|           e2e             |
|                           |
|    -------------------    |
|        integration        |
|                           |
+---------------------------+
|          unit             |
|                           |
+---------------------------+


"Unit-тесты - одни из лучших индикаторов качества кода в проекте"

---
e2e - функциональные тесты - тестирует систему как если бы ей пользовался пользователь
проверяет приложение на соответствие функциональным требованиям.
т.е бекенд может проверить ендпоинты
фронт, заполнение полей формы
(выполняются медленно, говорят что в системе что-то не так, но кто виноват не говорят)

Тест, который делает запрос в приложение, а потом лезет в базу данных проверять результат, не является настоящим функциональным тестом.

Функциональное тестирование не про базу данных, оно о приложении в целом. Поэтому нормальные функциональные тесты не лезут внутрь приложения, они работают снаружи.
---
Интеграционные тесты, тестирует взаимодействия нескольких модулей
у Фронта, исп. несколько компонентов + стора которая работает вместе с ними
у Бека
Попросить UserService зарегистрировать нового пользователя и проверить, что новая строка создана в базе данных, нужное событие (UserRegistered) было сгенерировано и соответствующий email был послан.

---
unit тесты - теструют один конкретный модуль
(выполняются быстро, способны локализовать проблемы в рамках одного юнита и не всегда они проверяют общую бизнес логику)

unit тесты - функционирует как инструмент описания бизнес требований к модулю
тесты проверяют что выполняются бизнес требования
unit тесты осущ. очень важную задачу, документирование поведения конкретного узла системы

когда тест становится красным, позволяет не бегать по всей системе, а сказать так вот в этом файле что-то пошло не так

unit тесты должно быть легко писать чтоб о них было легко думать, иначе любой сложный запутанный unit тест говорит о том что архитектура вашей системы несколько хромает и если это сложно понимать в тесте, значит и саму систему сложно понять и нужно ее упрощать

осн задача ради которой мы разбиваем любую систему на отдельные узлы, это снижение ментальной сложности

каждому файлу соо-ует файл теста, нет логики нет тестов

никогда не занимайтесь тем что просто бездумно пишите тесты, например, на все методы класса, это плохой и тупиковый подход, потому что такие тесты очень редко несут бизнес ценности, большая часть методов класса являеются внутренними

тесты проверяют утверждения о модуле который мы сами себе составили
т.е тесты проверяют сценарии которые мы написали
когда тест зеленый, не всегда означает что модуль рабочий
но если мы обнаружимваем что модуль не рабочий, а тесты остаются зелеными, мы просто дописываем новые тесты
Если тест является красным, то проблема должна быть в модуле который тестируется



+---------+
|         |
|    B    |
|         |
+---------+
     ^
     |
+----+----+
|         |
|    A    |
|         |
+---------+


есть модуль A который взаимодействует с модулем B
A -> B
и например какой то метод из модуля B, который исп. модуль А, присылает не корректные данные
модуль А, соо-о упадет

и тесты модуля А, укажут что модуль А не работает

но на самом деле, модуль А ведет себя корректно, это модуль проблема с модулем B
мы должны по хорошему полностью изолировать модуль А от чужого кода
т.е значит там где у нас в модуле А вызвался модуль Б, должно быть вызвано что-то другое
и так должно быть во всеми внешними зависимостями модуля А


                   +---------+
+----------+       |         |
|          |       |    B    |
|  B fake  |       |         |
|          |       +---------+
+-----+----+            ^
      |          +-+----+----+-+
      |          | +---------+ |
      +--------->| |         | |
                 | |    A    | |
                 | |         | |
                 | +---------+ |
                 +-+---------+-+


Самое важное в unit тестах
Честность и не хрупкость

Честность - падение нашего теста указывает нам на проблемы именно модуля который он тестирует, проблемы в любых других модулях не должны приводить к падению нашего теста.
Если мы знаем что наш модуль не работает, но тесты являются зелеными, то мы расширяем тесты, для того чтобы тесты стали красными и потом чиним модуль

хрупкость:
тестировать мы можем только то что наш модуль предоставляет наружу

рефакторинг модуля А при котором внешнее поведение сохраняется, не приводит к падению теста

----

Любой тест состоит из 3х шагов
AAA - шаблон

Arrange - Подготовка
Act - Выполнение
Assert - Проверка

в Act фазе должны быть только те операции которые мы реально тестируем иначе если там будет слишком много операции, окажется что наш тест перестает быть честным


-----


5 видов заменимых объектов
1. Dummy
например модулю нужен объект конфигурации, можно подсунуть в Dummy пустой конфиг

2. Fake
фейковые объекты, содержат в себе логику, только они как-то ее упрощают

3. Stub
заглушка, просто содержит набор правил
когда вызывается метод, возвращает заранее известные даные
содержит набор правил как отвечать

4. Spy
внутри себя отслеживает какое-то состояние, например сколько раз была отправлена почта

5. Mocks
заглушка, которая содержит ожидания, о том с какими параметрами она будет вызвана

например, будет вызван метод с параметарми (x1,x2)
и если он будет вызвана с др. параметрами, на которые он не настроен, это приведет к провалу теста
если вызовем неизвестный метод, тест упадет


Fake, Stub и Mocks имеют общее имя - test doubles, название для объектов, которые подставляются вместо реальных с целью тестирования.

------

но тут проблема
Stub ->
[{id}, {id}, {id}]
прошел рефакторинг

[1,2,3,4,5]


------

Fixtures:
это Stub которые связаны не с реализации конкретных элементов вашей системы, а являются зафиксированными ответами

пример для фронта
т.е это некие данные, которые подменяются ответа бекенда
front -> /books/5
backend -> json

для бекенда
база данных которая загружается в бекенде перед началом тестов

как и стабы Fixtures могут устареват, т.е реально на бекенде могут быть др данные, а через
Fixtures вовзращаются старые данные


решение:
1. типизировать бекенд
например исп. OpenApi, где есть схемы

2. создавать фикстуры заранее

-----------

когда не нужно писать тесты:

Стартап, pre-seed стадия, когда не дали денег
_> смена стартапа
(упр. серверами -> продвинутое логировавание)


A\B тестирование

большой проект, часть от большого проекта
не несет коммерческой ценности


----

Чистая функция - это функция, результат которой зависит только от введенных данных. Она не меняет никакие внешние значения и просто вычисляет результат. Нет побочных эффектов

нет - шаблона AAA

Тесты чистых функций тоже имеют эти 3 части, но все они располагаются в одной строке кода.


Тестирование классов с состоянием

Конструктор класса Post - чистая функция, поэтому тесты для нее подобны предыдущим.
Однако, метод publish зависит от текущего состояния объекта и части тестов более ощутимы.
Тестирование классов с состоянием сложнее тестирования чистых функций, поскольку разработчик должен держать в голове состояние объекта.

StringHelper - внутреняя зависимость



----

Пример слоя приложения

Вызов \Event::fake() трансформирует Laravel-фасад Event в мок-объект.
Вызов \Event::assertDispatched проверяет, что это событие было вызвано.

Это не является unit-тестом. Фасад \Event был заменен моком, но база данных - нет.
Тесты проверяют только генерацию событий. Для того, чтобы проверить создание записей в базе данных нужно использовать вызовы методов, таких как assertDatabaseHas, которое делает этот тест неким интеграционным тестом к Слою Приложения, поскольку он просит Слой Приложения что-то сделать и проверяет результат тоже вызвав его.
Зависимости класса BookService не описаны явно. Чтобы понять, что конкретно он требует для своей работы, нужно просмотреть весь его код. Это делает написание тестов для него весьма неудобным. Хуже всего, если в класс будет добавлена новая зависимость с помощью laravel-фасада. Тесты будут продолжать работать как ни в чем не бывало, но не с моком, а с реальной реализацией этого фасада: реальные вызовы API и т.д.


----

Это корректный unit-тест. Класс BookService был протестирован в полной изоляции, не касаясь среды Laravel и базы данных.
проблемы:
-нужно было создать абстракцию с репозиторием исключительно для того, чтобы написать unit-тесты.
-Eloquent Models уже предоставляют вам преимущества Repository шаблона.
-Запрещены почти все операции Eloquent. Да, они будут работать корректно в реальном приложении, но не в unit-тестах.
-у разработчиков появится вопрос - "а для чего нам эти unit-тесты?"
-такие unit-тесты очень сложные. Их сложно писать и сложно читать. а пример простой создание сущности
-Каждая добавленная зависимость заставит переписывать все unit-тесты.

Вывод:
Если код сложно тестировать, скорее всего он обладает высокой связанностью.

Класс BookService содержит основную логику (проверку на уникальность имени и создание сущности), а также логику приложения (транзакции базы данных, генерация событий, отправку почты и т.д.). Это может быть исправлено отделением Слоёв Приложения и Доменной Логики.


Программные объекты внутри модуля должны быть сфокусированы на одной ответственности, т.е иметь сильную связность. Когда методы класса полностью независимы друг от друга, класс не является модулем. Каждый метод класса - это модуль в данном случае.


helper
Post
OrderService
FuzBaz
Tennis
BookService
Book Model
Category Model
User Model
Func Test
File
