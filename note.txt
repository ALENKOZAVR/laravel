https://zoom.us/s/89502170762#success









под каждую бд, php нужные свои библиотеки
pdo_mysql pdo_pgsql



https://www.php.net/manual/ru/book.mysqli.php

....
mysqli_result::fetch_all
Выбирает все строки из результирующего набора и помещает их в ассоциативный массив, обычный массив или в оба

mysqli_result::fetch_array
Выбирает следующую строку из набора результатов и помещает её в ассоциативный массив, обычный массив или в оба

mysqli_result::fetch_assoc
Выбирает следующую строку из набора результатов и помещает её в ассоциативный массив

mysqli_result::fetch_column
Получает один столбец из следующей строки набора результатов
....

https://www.php.net/manual/ru/book.pgsql.php

pg_result_status
Возвращает состояние результата запроса

pg_select
Выбирает записи из базы данных

pg_send_execute
Запускает предварительно подготовленный SQL-запрос и передаёт ему параметры; не ожидает возвращаемого результата

pg_send_prepare
Посылает запрос на создание параметризованного SQL-выражения, не дожидаясь его завершения

pg_send_query_params
Посылает параметризованный запрос на сервер, не ожидает возвращаемого результата

....

https://www.php.net/manual/ru/book.pdo.php
PDO - PHP Data Objects, клиент для работы с БД
PDO это некая абстракция, есть драйверы которые адаптируют стандартные апи к этой абстракции

PDO::lastInsertId — Возвращает ID последней вставленной строки или значение последовательности
PDO::prepare — Подготавливает запрос к выполнению и возвращает связанный с этим запросом объект
PDO::query — Подготавливает и выполняет выражение SQL без заполнителей
PDO::quote — Заключает строку в кавычки для использования в запросе

....


есть много драйверов
Драйверы PDO
CUBRID (PDO) — Функции CUBRID (PDO_CUBRID)
Firebird (PDO) — Функции Firebird (PDO_FIREBIRD)
IBM (PDO) — Функции IBM (PDO_IBM)
Informix (PDO) — Функции Informix (PDO_INFORMIX)
MySQL (PDO) — Функции MySQL (PDO_MYSQL)
MS SQL Server (PDO) — Функции модуля PDO_SQLSRV для Microsoft SQL Server
Oracle (PDO) — Функции Oracle (PDO_OCI)
PostgreSQL (PDO) — Функции PostgreSQL (PDO_PGSQL)
SQLite (PDO) — Функции SQLite (PDO_SQLITE)

-----------------

$db_mysql = new \PDO("mysql:host={$this->host};dbname={$this->name}", $this->user, $this->pass);
$db_mysql->setAttribute(\PDO::ATTR_ERRMODE, \PDO::ERRMODE_EXCEPTION);

$db_pgsql= new \PDO("pgsql:host={$this->host};port={$this->port};dbname={$this->name}", $this->user, $this->pass);

mysql - это тип драйвера
mysql:host={$this->host};dbname={$this->name}
все эти параметры и вид стройки берется из документации

то как pdo будет обрабатывать ошибки
\PDO::ATTR_ERRMODE, \PDO::ERRMODE_EXCEPTION

-----------------

$db_mysql->exec("create table if not exists users (
        id int primary key auto_increment,
        email varchar(45) NOT NULL,
        password varchar(255) NOT NULL
    )"
);
$db_psql->exec("create table if not exists users (
        id serial primary key,
        email varchar(45),
        password varchar(255)
    )"
);

-----------------

$sth = $db_mysql->prepare('INSERT INTO posts (title, user_id, month) values (:title, :user, :month)');
$sth->execute([
    'title' => $post['title'],
    'user' => $post['user_id'],
    'month' => $post['month'],
]);

-----------------

$sth = $db_mysql->prepare("UPDATE posts SET month = :month WHERE id = :id");
$sth->execute([
    'month' => 'Mart',
    'id' => 2
]);

-----------------

$sth = $db_mysql->prepare('DELETE FROM posts WHERE id = :id');
$sth->execute(['id' => 1]);

-----------------

$sth = $db_mysql->query('SELECT * FROM posts ORDER BY month');
$row = $sth->fetchAll(\PDO::FETCH_OBJ);
$row = $sth->fetch(\PDO::FETCH_OBJ);

$page = 5;
$limit = 10;
$sth = $db_mysql->query('SELECT * FROM posts LIMIT 10 OFFSET 50');
$row = $sth->fetchAll(\PDO::FETCH_OBJ);

$sth = $db_mysql->query('SELECT users.email as user_email, posts.title as post_title FROM posts INNER JOIN users ON users.id = posts.user_id LIMIT 10');
$row = $sth->fetchAll(\PDO::FETCH_OBJ);

-----------------

в pdo 3 метода
exec
prepare
query
3 метода с помощью которых можно взаимодействовать с бд и отправлять запросы


разница между
prepare
$sth = $db_mysql->prepare('SELECT * FROM users WHERE email = :email');
$sth->execute(['email' => $email]);
// Можно выполнять все виды запросов в том числе и извлечение данных,
// можно использовать placeholder (пользовательские данные)

query
$email = test@gm.com
$sth = $db_mysql->query('SELECT * FROM users WHERE email = "test@gm.com"');
// Можно выполнять все виды запросов в том числе и извлечение данных,
//нельзя использовать placeholder (пользовательские данные)

exec
$db_mysql->exec('DELETE FROM users WHERE id = 1');
// нельзя извлечь данные
// нельзя использовать placeholder (пользовательские данные)


Запросы обычно пишутся в таком виде
SELECT ... FROM  ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT ... DESC

HAVING это как where, за одним исключением, HAVING фильтрует столбцы после группировки
WHERE фильтрует столбцы до группировки

INNER JOIN (JOIN) — каждая строка из первой (левой) таблицы, сопоставляется с каждой строкой из второй (правой) таблицы, после чего, происходит проверка условия.

LEFT JOIN (LEFT OUTER JOIN) — важен порядок следования таблиц. Сначала происходит формирование таблицы соединением INNER JOIN. Затем, в результат добавляются записи левой таблицы, не вошедшие в результат после INNER JOIN. Для них, соответствующие записи из правой таблицы заполняются значениями NULL.

-----------------

Паттерны для работы с бд и ORM
Active Record, Data Mapper, Query Builder


Active record
Eloquent является реализацией шаблона Active Record.

Данный шаблон берет на себя две ответственности: первая — сущность (например, пользователь, заказ, проект и т.д.) и вторая — взаимодействие с хранилищем данных (простыми словами, он умеет себя доставать из БД, обновлять и удалять).
Класс User, наследуясь от Eloquent Model, наследует огромный пласт кода, который работает с базой данных и сам становится навеки связанным с ней.
Этот код не может быть покрыт unit-тестами. Приходится постоянно держать в голове базу данных

Минусы:
-Модели Active Record нарушаю принципы SOLID. Согласно принципу, доменный объект должен иметь только одну зону ответственности
-Реализации сохранения данных тесно связана с бизнес-логикой
-Сложно тестировать

Плюс:
-Быстрая разработка, RAD
-Простота работы со связями (relations)

Data mapper
Библиотеки, реализующие шаблон Data mapper, пытаются снять эту нагрузку.
Классы сущностей там - обычные классы, которые не обязаны наследоваться от какого-то класса Model.
Data Mapper является прослойкой между сущностью и хранилищем данных. Он служит для облегчения сущности путем взятия на себя ответственности по работе с хранилищем данных. Другими словами, при использовании Data Mapper сущность (пользователь, заказ, проект и т.д.) работает только со своими данными и бизнес-логикой, а сохранять, обновлять и удалять её будет другая часть системы.
Когда разработчик хочет сохранить состояние сущности в базе данных, он вызывает метод persist у Data Mapper библиотеки и она, используя некоторую мета-информацию про то, как именно нужно хранить эту сущность в базе данных, обеспечивает их маппинг в базу данных и обратно.

Плюс:
-Каждый объект имеет свою зону ответственности, тем самым следую принципам SOLID и сохраняя каждый объект простым и по существу.
-Тестирование

Минусы:
-Код намного более сложный, чем код Eloquent
-Сложные запросы

Выбор ORM вытекать из бизнес задач.
Active Record - чаcть RAD (rapid application development - быстрая разработка приложений), и цель его быстро развернуть уровень доменных моделей (бизнес логики) по существующей схеме базы.
Фактически все RAD проекты строятся по принципу «Database First» — т.е. мы вначале проектируем схему БД, как-то ее декларируем (Json, Yaml, SQL) и через эту декларацию фреймворк генерирует нам доменные модели с уже реализованным CRUD функционалом через механизм scaffolding-a.

Если проект большой, много сложных сущностей — с большим количеством логики и необходимостью хранить данные этой сущности в нескольких таблицах
или когда сначала нужно описать бизнес-логику, а потом уже думаете над тем как её сохранить в подходящих хранилищах
можно брать DataMapper - Code First

Это разные ORM, написанные с разными целями.
-------------
Databases. Configuration

Eloquent:
php artisan make:model Blog
php artisan make:model Blog -m

php artisan make:model Blog -m -r -f
-m - создает миграцию
-r - создает контролер с CRUD методами
-f - создание фабрики

public $timestamps = false; - отключить created_at, updated_at
protected $table = 'my_products';
protected $connection = 'connection-name'; // sqlite
protected $fillable = ['name', 'price']; // Атрибуты, для которых разрешено массовое присвоение значений.
protected $guarded = []; //  Атрибуты, для которых НЕ разрешено массовое присвоение значений.
protected $hidden = ['password']; // Атрибуты, которые должны быть скрыты из массивов.
protected $casts = ['admin' => 'boolean']

https://laravel.su/docs/8.x/eloquent


Eloquent · Отношения
Один к одному
users
    id - integer
    name - string

phones
    id - integer
    user_id - integer
    number - string

class User extends Model
{
    public function phone()
    {
        return $this->hasOne(Phone::class, 'user_id', 'id');
    }
}
class Phone extends Model // user_id
{
    public function user()
    {
        return $this->belongsTo(User::class, 'user_id', 'id');
        //return $this->belongsTo(User::class, 'foreign_key');
    }
}
$user = User::find(1)
$user->phone
$phone = Phone::find(1)
$phone->user

---------

Один ко многим
posts
    id - integer
    name - string

comments
    id - integer
    post_id - integer
    text - string
class Post extends Model
{
    public function comments()
    {
        return $this->hasMany(Comment::class);
    }
}
class Comment extends Model
{

    public function post()
    {
        return $this->belongsTo(Post::class);
    }
}


$post = Post::find(1)
$post->comments()->where('id', 5)
$post->comments

Многие ко многим
class User extends Model
{
    public function roles()
    {
        return $this->belongsToMany(Role::class);
    }
}
class Role extends Model
{
    public function users()
    {
        return $this->belongsToMany(User::class);
    }
}
users
    id - integer
    name - string

roles
    id - integer
    name - string

role_user
    user_id - integer
    role_id - integer


https://laravel.su/docs/8.x/eloquent-relationships

------------------


Запросы ActiveRecord\QueryBuilder - ORM

CREATE:
$car = new Car;
$car->name = "Машина 1 модель 5";
$car->save();

raw: INSERT INTO cars ('name')
VALUES ('Новое название')

READ:
$car = Car::find(1);
$car = Car::where('id', 1)->get();
$car = Car::where('id', 1)->where('name', 'Имя машины')->get();
$cars = Car::all();

raw: SELECT * FROM cars
raw: SELECT * FROM cars WHERE id = 1 AND name = 'Имя машины'

UPDATE:
$car = Car::find(1);
$car->name = "Машина 1 модель 6";
$car->save();

raw: UPDATE cars SET name='Машина 1 модель 6' WHERE id=1

DELETE:
$car = Car::find(1);
$car->delete();
raw: DELETE FROM cars WHERE id = 1

Примеры запросов с документации
$flights = Flight::where('active', 1)
               ->orderBy('name')
               ->take(10) //limit
               ->get();
$flight = Flight::where('number', 'FR 900')->first();
$flight = Flight::where('legs', '>', 3)->firstOrFail();

Product::join('company’, 'companies.id', '=',
'products.company_id')->where('companies.city_id', $cityId)->select('products.*')


QueryBuilder:
Query Builder - конструктор запросов - предоставляет удобный, выразительный интерфейс для создания и выполнения запросов к базе данных. Он может использоваться для выполнения большинства типов операций и работает со всеми поддерживаемыми СУБД.

CREATE:
DB::table('users')->insert([
    ['email' => 'picard@example.com', 'votes' => 0],
    ['email' => 'janeway@example.com', 'votes' => 0],
]);

READ:
$users = DB::table('users')->get();
$user = DB::table('users')->where('name', 'John')->first();
$user = DB::table('users')->find(3); // ->where('id', 3)->first();

$users = DB::table('users')
            ->select('name', 'email as user_email')
            ->get();

$users = DB::table('users')
            ->join('contacts', 'users.id', '=', 'contacts.user_id')
            ->join('orders', 'users.id', '=', 'orders.user_id')
            ->select('users.*', 'contacts.phone', 'orders.price')
            ->orderBy('users.name', 'desc')
            ->get();


UPDATE:
DB::table('users')->where('id', 1)->update(['votes' => 1]);

DELETE:
$deleted = DB::table('users')->delete();
$deleted = DB::table('users')->where('votes', '>', 100)->delete();

RAW SQL
исп. когда ORM или QB ограничивает нас

Когда работаем с raw sql, не забывать про sql инъекции, нужно очищать данные которые приходят из вне
DB::select("UPDATE cars SET name='Обновленное название' WHERE id=1")

$price = $_POST['price']; // 1.0825
DB::table('orders')->selectRaw('price * ? as price_with_tax', [$price])->get();

$orders = DB::table('orders')->whereRaw('price > IF(state = "TX", ?, 100)', [200])->get();


---------------------

Миграции — системы контроля версий для вашей базы данных.

php artisan make:migration create_users_table --create=users
php artisan make:migration add_votes_to_users_table --table=users // update_users_table
php artisan migrate - накатить миграции
php artisan migrate:rollback --step=5 - откатить последние миграции
php artisan migrate:reset - откатить все миграции
php artisan migrate:refresh - откатить все миграции и заново накатить
php artisan migrate:refresh --seed  - Обновляем базу данных и запускаем все наполнители базы данных


+-------------------+---------------------------------------+---------------------+---------------------------------+
|        Что        |                Правило                |       Принято       |           Не принято            |
+-------------------+---------------------------------------+---------------------+---------------------------------+
| Таблица           | мн.число                              | article_comments    | article_comment,articleComments |
| Pivot таблица     | имена моделей в алф.порядке, в ед.ч.  | article_user        | user_article                    |
| Столбец в таблице | snake_case без имени модели           | meta_title          | metaTitle,MetaTitle             |
| Свойство в модели | snake_case                            | $model->meta_title  | metaTitle,MetaTitle             |
| Внешний ключ      | имя модели ед.ч. и _id                | article_id          | id_article                      |
| Первичный ключ    | -                                     | id                  | custom                          |
| Миграция          | -                                     | create_users_table  | users                           |
| Миграция          | -                                     | update_users_table  | users_update                    |
+-------------------+---------------------------------------+---------------------+---------------------------------+

указаны все типы колонок для миграций
https://laravel.su/docs/8.x/migrations#columns

$table->string('title');
$table->integer('price');
$table->boolean('confirmed');

->nullable();
->default();
->unique(); создание индекса
->unsigned(); без знаковое

Индекс – это отсортированный набор значений. В MySQL индексы всегда строятся для какой-то конкретной колонки.

https://highload.today/indeksy-v-mysql/

$table->primary('id');	Добавить первичный ключ.
$table->primary(['id', 'parent_id']);	Добавить составной ключ.
$table->unique('email');	Добавить уникальный индекс.
$table->index('state');	Добавляет простой индекс.
$table->fulltext('body');	Добавляет полнотекстовый индекс.


Удаление
$table->dropPrimary('users_id_primary');
$table->dropUnique('users_email_unique');
$table->dropIndex('geo_state_index');

----------------

Про внешние ключи, это про ограничения целостности базы данных
$table->foreign('category_id')->references('id')->on('categories');

зачем нужны
это т.н ссылочная целостность, post не может быть создан без категории
если при создании поста, указываем не сущ. Id категорию, то будет ошибка
Cannot add or update a child row: a foreign key constraint fails

Без внешних ключей ссылочную целостность обеспечивает приложение.
Таким образом, если в приложении что-то пошло не так, вы можете получить странные данные в БД (например, заказы для несуществующего пользователя).


ON DELETE RESTRICT
означает, что если попробовать удалить категорию, у которого в таблице посты есть данные, БД не даст этого сделать:
Cannot delete or update a parent row: a foreign key constraint fails

ON DELETE CASCADE
бд, при удалении категории, удаляются

ON UPDATE CASCADE, если изменится id категории, то в постах авт. изменится category_id
ON UPDATE RESTRICT

sail artisan db:wipe
sail artisan migrate:refresh --seed


---------------------------

Soft Delete

---------------------------

Products::with('company')->get();

$products = Products::all();
if ($withCompany) {
	$products->load('company');
}

$products = Products::query();
if ($withCompany) {
    $products = $products->with('company');
}
$products = $products->all();

---------------------------

Seeding

Seeding - простой механизм наполнения вашей БД начальными
данными с помощью специальных классов, которые хранятся в директории
database/factories. Создать seeder можно командой:

php artisan make:factory PostFactory
php artisan db:seed // запустить загрузку данных
php artisan migrate:refresh --seed // откатить миграции и запустить загрузку

https://fakerphp.github.io/formatters/date-and-time/
https://laravel.su/docs/8.x/database-testing#defining-model-factories


-------------

Транзакция представляет собой группу запросов SQL, обрабатываемых атомарно, то есть как единое целое. Если подсистема базы данных может выполнить всю группу запросов, она делает это, но если какой-либо запрос не может быть выполнен в результате сбоя или по иной причине, ни один запрос группы не будет выполнен.
Вы начинаете транзакцию командой START TRANSACTION, а затем либо сохраняете изменения командой COMMIT, либо отменяете их командой ROLLBACK.

mysql:
START TRANSACTION;
SELECT balance FROM checking WHERE customer_id = 10233276;
UPDATE checking SET balance = balance - 200.00 WHERE customer_id = 10233276;
UPDATE savings SET balance = balance + 200.00 WHERE customer_id = 10233276;
COMMIT;

DB::beginTransaction();
DB::rollBack();
DB::commit();
